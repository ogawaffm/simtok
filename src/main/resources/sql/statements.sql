-- ============================================
-- Setup: schema and base types/domains
-- ============================================

-- Create a dedicated schema
CREATE SCHEMA "test_lab";

-- Set the schema for this session (standard way via SET PATH)
SET PATH "test_lab", PUBLIC;

-- Define a domain with a constraint
CREATE DOMAIN "email_dom" AS CHARACTER VARYING(254)
    CHECK ("email_dom" SIMILAR TO '%@%\\..+');

-- Define an enumerated type via standard CREATE TYPE (distinct type example)
CREATE TYPE "usd_amount" AS DECIMAL(18,2);

-- Create a user-defined structured type (SQL standard UDT)
CREATE TYPE "address_t" AS
    (
    "street"      CHARACTER VARYING(120),
    "city"        CHARACTER VARYING(80),
    "postal_code" CHARACTER VARYING(20),
    "country"     CHARACTER VARYING(2)
    ) FINAL;

-- ============================================
-- Tables with a variety of constraints
-- ============================================

-- Parent table with deferred constraints and generated columns (computed via expression)
CREATE TABLE "company"
(
    "company_id"       INTEGER GENERATED BY DEFAULT AS IDENTITY
        PRIMARY KEY,
    "name"             CHARACTER VARYING(200) NOT NULL,
    "founded_on"       DATE,
    "is_active"        BOOLEAN DEFAULT TRUE NOT NULL,
    "hq_address"       "address_t",
    "created_at"       TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    CONSTRAINT "chk_company_name_len"
        CHECK (CHAR_LENGTH("name") >= 2) DEFERRABLE INITIALLY IMMEDIATE
);

-- Child table with composite PK, FK, unique, and exclusion-like constraint via CHECK
CREATE TABLE "employee"
(
    "employee_id"      INTEGER GENERATED BY DEFAULT AS IDENTITY,
    "company_id"       INTEGER NOT NULL,
    "emp_no"           CHARACTER VARYING(20) NOT NULL,
    "first_name"       CHARACTER VARYING(60) NOT NULL,
    "last_name"        CHARACTER VARYING(60) NOT NULL,
    "email"            "email_dom" NOT NULL,
    "hired_at"         DATE DEFAULT CURRENT_DATE NOT NULL,
    "salary"           "usd_amount" DEFAULT 0.00,
    "manager_id"       INTEGER,
    "is_contractor"    BOOLEAN DEFAULT FALSE NOT NULL,
    PRIMARY KEY ("employee_id"),
    UNIQUE ("company_id", "emp_no"),
    CONSTRAINT "fk_emp_company"
        FOREIGN KEY ("company_id") REFERENCES "company" ("company_id")
            ON UPDATE CASCADE ON DELETE RESTRICT
            DEFERRABLE INITIALLY DEFERRED,
    CONSTRAINT "fk_emp_manager"
        FOREIGN KEY ("manager_id") REFERENCES "employee" ("employee_id")
            ON UPDATE CASCADE ON DELETE SET NULL,
    CONSTRAINT "chk_salary_non_negative"
        CHECK ("salary" >= 0.00)
);

-- Table with composite primary key and multiple foreign keys
CREATE TABLE "project"
(
    "project_id"   INTEGER GENERATED BY DEFAULT AS IDENTITY,
    "company_id"   INTEGER NOT NULL,
    "code"         CHARACTER VARYING(30) NOT NULL,
    "title"        CHARACTER VARYING(200) NOT NULL,
    "starts_on"    DATE NOT NULL,
    "ends_on"      DATE,
    "budget"       "usd_amount" DEFAULT 0.00,
    "active"       BOOLEAN DEFAULT TRUE NOT NULL,
    PRIMARY KEY ("project_id"),
    UNIQUE ("company_id", "code"),
    CONSTRAINT "fk_proj_company"
        FOREIGN KEY ("company_id") REFERENCES "company" ("company_id")
            ON UPDATE CASCADE ON DELETE CASCADE
);

-- Association table with composite key and additional attributes
CREATE TABLE "assignment"
(
    "project_id"   INTEGER NOT NULL,
    "employee_id"  INTEGER NOT NULL,
    "role"         CHARACTER VARYING(80) NOT NULL,
    "allocated_pct" NUMERIC(5,2) DEFAULT 100.00,
    "assigned_at"  TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    PRIMARY KEY ("project_id", "employee_id"),
    CONSTRAINT "fk_asg_project"  FOREIGN KEY ("project_id")  REFERENCES "project"  ("project_id"),
    CONSTRAINT "fk_asg_employee" FOREIGN KEY ("employee_id") REFERENCES "employee" ("employee_id"),
    CONSTRAINT "chk_alloc_range" CHECK ("allocated_pct" BETWEEN 0 AND 200)
);

-- Table to show constraints with MATCH PARTIAL (standard) and ON DELETE SET DEFAULT
CREATE TABLE "contact_pref"
(
    "employee_id"  INTEGER NOT NULL,
    "email_ok"     BOOLEAN DEFAULT TRUE,
    "sms_ok"       BOOLEAN DEFAULT FALSE,
    "phone_ok"     BOOLEAN DEFAULT FALSE,
    "preferred"    CHARACTER VARYING(10) DEFAULT 'email',
    PRIMARY KEY ("employee_id"),
    FOREIGN KEY ("employee_id") REFERENCES "employee" ("employee_id")
        MATCH SIMPLE ON UPDATE CASCADE ON DELETE CASCADE
);

-- ============================================
-- Transactions and deferrable constraints
-- ============================================

START TRANSACTION;
SET CONSTRAINTS ALL DEFERRED;

INSERT INTO "company" ("name", "founded_on", "hq_address")
VALUES
    ('Acme Corp', DATE '1999-01-01', ROW('1 Rocket Rd', 'Metropolis', '12345', 'US')),
    ('Globex',     DATE '2005-05-20', ROW('42 Evergreen', 'Springfield', '54321', 'US'));

-- Insert employees, including self-referencing manager to test deferred FK
INSERT INTO "employee" ("company_id", "emp_no", "first_name", "last_name", "email", "hired_at", "salary", "manager_id")
VALUES
    (1, 'E-0001', 'Alice',  'Anderson', 'alice.anderson@acme.com', DATE '2020-03-01', 120000.00, NULL),
    (1, 'E-0002', 'Bob',    'Brown',    'bob.brown@acme.com',      DATE '2021-05-15',  90000.00, 1),
    (1, 'E-0003', 'Chad',   'Clark',    'chad.clark@acme.com',     DATE '2022-02-10',  80000.00, 1),
    (2, 'G-1001', 'Dora',   'Davis',    'dora.davis@globex.com',   DATE '2019-07-07', 110000.00, NULL);

-- Projects
INSERT INTO "project" ("company_id", "code", "title", "starts_on", "ends_on", "budget", "active")
VALUES
    (1, 'ROCKET', 'Rocket Reboot', DATE '2023-01-01', NULL, 500000.00, TRUE),
    (1, 'ANVIL',  'Anvil 2.0',     DATE '2023-06-01', DATE '2024-06-01', 150000.00, FALSE),
    (2, 'XRAY',   'X-Ray Vision',  DATE '2024-02-01', NULL, 250000.00, TRUE);

-- Assignments
INSERT INTO "assignment" ("project_id", "employee_id", "role", "allocated_pct")
SELECT p."project_id", e."employee_id",
       CASE WHEN e."first_name" LIKE 'A%' THEN 'Lead' ELSE 'Engineer' END AS "role",
       100.00
FROM "project" AS p
         JOIN "employee" AS e ON e."company_id" = p."company_id";

COMMIT;

-- ============================================
-- Basic and advanced SELECT patterns
-- ============================================

-- 1) Simple projection with aliases and CASE, ORDER BY with explicit column position and NULLS
SELECT
    e."employee_id" AS "id",
    e."first_name" || ' ' || e."last_name" AS "full_name",
    e."email",
    CASE
        WHEN e."salary" >= 100000.00 THEN 'high'
        WHEN e."salary" BETWEEN 70000.00 AND 99999.99 THEN 'medium'
        ELSE 'low'
        END AS "salary_band"
FROM "employee" AS e
ORDER BY 4 DESC NULLS LAST, 2 ASC;

-- 2) DISTINCT with FILTER on aggregate (standard SQL)
SELECT
    e."company_id",
    COUNT(*) FILTER (WHERE e."is_contractor" = FALSE) AS "employee_count",
    AVG(e."salary") AS "avg_salary"
FROM "employee" AS e
GROUP BY e."company_id";

-- 3) GROUPING SETS / ROLLUP / CUBE
SELECT
    c."name" AS "company",
    p."code" AS "project_code",
    SUM(a."allocated_pct") AS "total_allocation"
FROM "assignment" a
         JOIN "project"   p ON p."project_id" = a."project_id"
         JOIN "company"   c ON c."company_id" = p."company_id"
GROUP BY GROUPING SETS
    (
    (c."name", p."code"),
    (c."name"),
    ()
    )
ORDER BY c."name" NULLS FIRST, p."code" NULLS FIRST;

-- Same data using ROLLUP
SELECT
    c."name" AS "company",
    p."code" AS "project_code",
    SUM(a."allocated_pct") AS "total_allocation"
FROM "assignment" a
         JOIN "project"   p ON p."project_id" = a."project_id"
         JOIN "company"   c ON c."company_id" = p."company_id"
GROUP BY ROLLUP (c."name", p."code");

-- Same data using CUBE
SELECT
    c."name" AS "company",
    p."code" AS "project_code",
    SUM(a."allocated_pct") AS "total_allocation"
FROM "assignment" a
         JOIN "project"   p ON p."project_id" = a."project_id"
         JOIN "company"   c ON c."company_id" = p."company_id"
GROUP BY CUBE (c."name", p."code");

-- 4) Window functions with named windows and frames
SELECT
    e."company_id",
    e."employee_id",
    e."last_name",
    e."salary",
    AVG(e."salary") OVER w AS "avg_by_company",
    SUM(e."salary") OVER (PARTITION BY e."company_id"
                          ORDER BY e."salary"
                          ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS "running_sum",
    RANK() OVER w AS "rank_in_company"
FROM "employee" e
WINDOW w AS (PARTITION BY e."company_id" ORDER BY e."salary" DESC);

-- 5) Subqueries: scalar, IN/EXISTS, quantified comparisons ANY/ALL
SELECT
    e."employee_id",
    e."first_name",
    e."salary",
    e."salary" - (SELECT AVG(e2."salary") FROM "employee" e2 WHERE e2."company_id" = e."company_id") AS "delta_from_avg",
    CASE WHEN EXISTS (
        SELECT 1 FROM "assignment" a WHERE a."employee_id" = e."employee_id"
    ) THEN TRUE ELSE FALSE END AS "has_assignment",
    e."salary" >= ALL (SELECT p."budget" / 10 FROM "project" p WHERE p."company_id" = e."company_id") AS "gte_all_proj_budgets_10pct"
FROM "employee" e;

-- 6) CORRELATED subquery in WHERE
SELECT e."employee_id", e."email"
FROM "employee" e
WHERE e."salary" > (
    SELECT COALESCE(AVG(e2."salary"), 0.00)
    FROM "employee" e2
    WHERE e2."company_id" = e."company_id" AND e2."employee_id" <> e."employee_id"
);

-- 7) LATERAL derived table (standard LATERAL)
SELECT c."name", x."token"
FROM "company" c,
     LATERAL (
              SELECT UNNEST(STRING_TO_ARRAY(c."name", ' ')) AS "token"
         ) AS x;
-- Note: STRING_TO_ARRAY/UNNEST are often extensions; if unavailable, replace with a VALUES(...) that references c."name".

-- 8) LIKE with ESCAPE and SIMILAR TO
SELECT e."email"
FROM "employee" e
WHERE e."email" LIKE '%@acme\_com%' ESCAPE '\'
    OR e."email" SIMILAR TO '%@(acme|globex)\\..+';

-- ============================================
-- Set operations (UNION, INTERSECT, EXCEPT)
-- ============================================

SELECT "email" FROM "employee" WHERE "company_id" = 1
UNION
SELECT "email" FROM "employee" WHERE "company_id" = 2;

SELECT "employee_id" FROM "employee" WHERE "salary" > 100000.00
INTERSECT
SELECT "employee_id" FROM "employee" WHERE "is_contractor" = FALSE;

SELECT "employee_id" FROM "employee"
EXCEPT
SELECT DISTINCT "employee_id" FROM "assignment";

-- ============================================
-- Updates with search conditions, FROM, and subqueries
-- ============================================

-- Update with searched CASE and FROM join
UPDATE "employee" AS e
SET "salary" = CASE
                   WHEN p."active" = TRUE THEN e."salary" * 1.05
                   ELSE e."salary"
    END
    FROM "assignment" a
JOIN "project" p ON p."project_id" = a."project_id"
WHERE a."employee_id" = e."employee_id";

-- Update via scalar subquery
UPDATE "project" p
SET "ends_on" = CURRENT_DATE
WHERE p."active" = FALSE
  AND p."ends_on" IS NULL
  AND p."project_id" IN (
    SELECT a."project_id"
    FROM "assignment" a
    GROUP BY a."project_id"
    HAVING SUM(a."allocated_pct") = 0
);

-- ============================================
-- DELETE variants
-- ============================================

-- Delete unreferenced projects using NOT EXISTS
DELETE FROM "project" p
WHERE NOT EXISTS (
    SELECT 1 FROM "assignment" a WHERE a."project_id" = p."project_id"
);

-- Delete with search condition using quantified comparison
DELETE FROM "employee" e
WHERE e."salary" < ANY (SELECT p."budget" / 100 FROM "project" p WHERE p."company_id" = e."company_id")
  AND e."is_contractor" = TRUE;

-- ============================================
-- INSERT variants
-- ============================================

-- INSERT ... VALUES multi-row
INSERT INTO "contact_pref" ("employee_id", "email_ok", "sms_ok", "phone_ok", "preferred")
VALUES
    (1, TRUE, FALSE, FALSE, 'email'),
    (2, TRUE, TRUE,  FALSE, 'sms')
;

-- INSERT ... SELECT with DISTINCT and ORDER BY (ORDER BY allowed when using FETCH FIRST)
INSERT INTO "assignment" ("project_id", "employee_id", "role", "allocated_pct")
SELECT DISTINCT p."project_id", e."employee_id", 'Reviewer', 10.00
FROM "project" p
         JOIN "employee" e ON e."company_id" = p."company_id"
ORDER BY p."project_id", e."employee_id"
    FETCH FIRST 5 ROWS ONLY;

-- ============================================
-- MERGE (standard upsert-like)
-- ============================================

MERGE INTO "contact_pref" AS cp
    USING (
        SELECT e."employee_id", TRUE AS "email_ok", FALSE AS "sms_ok", FALSE AS "phone_ok", 'email' AS "preferred"
        FROM "employee" e
        WHERE e."email" SIMILAR TO '%@acme\\..+'
    ) AS s
    ON (cp."employee_id" = s."employee_id")
    WHEN MATCHED THEN
        UPDATE SET "email_ok" = s."email_ok", "sms_ok" = s."sms_ok", "phone_ok" = s."phone_ok", "preferred" = s."preferred"
    WHEN NOT MATCHED THEN
        INSERT ("employee_id", "email_ok", "sms_ok", "phone_ok", "preferred")
            VALUES (s."employee_id", s."email_ok", s."sms_ok", s."phone_ok", s."preferred");

-- ============================================
-- Views (regular and recursive CTE usage)
-- ============================================

-- Simple view with column list
CREATE VIEW "v_active_projects" ("project_id", "company_id", "code", "title")
AS
SELECT p."project_id", p."company_id", p."code", p."title"
FROM "project" p
WHERE p."active" = TRUE
        WITH CASCADED CHECK OPTION;

-- View using window functions
CREATE VIEW "v_salary_rank"
AS
SELECT
    e."employee_id",
    e."company_id",
    e."first_name",
    e."last_name",
    e."salary",
    DENSE_RANK() OVER (PARTITION BY e."company_id" ORDER BY e."salary" DESC) AS "dense_rank_in_company"
FROM "employee" e;

-- ============================================
-- WITH and WITH RECURSIVE (hierarchies / sequences)
-- ============================================

-- Non-recursive CTE with multiple CTEs and reuse
WITH
    "active_emp" AS (
        SELECT * FROM "employee" WHERE "is_contractor" = FALSE
    ),
    "leader" AS (
        SELECT * FROM "employee" WHERE "manager_id" IS NULL
    )
SELECT l."employee_id" AS "leader_id",
       COUNT(ae."employee_id") AS "team_size"
FROM "leader" l
         LEFT JOIN "active_emp" ae ON ae."manager_id" = l."employee_id"
GROUP BY l."employee_id";

-- Recursive CTE for employee management tree
WITH RECURSIVE "org" ("root_id","employee_id","level") AS (
    SELECT e."employee_id", e."employee_id", 0
    FROM "employee" e
    WHERE e."manager_id" IS NULL
    UNION ALL
    SELECT o."root_id", e."employee_id", o."level" + 1
    FROM "employee" e
             JOIN "org" o ON e."manager_id" = o."employee_id"
)
                   SEARCH DEPTH FIRST BY "employee_id" SET "df_order"
                   CYCLE "employee_id" SET "is_cycle" USING "was_cycle"
SELECT * FROM "org" ORDER BY "df_order";

-- Numeric sequence generator via recursive CTE with termination
WITH RECURSIVE "nums"(n) AS (
    SELECT 1
    UNION ALL
    SELECT n + 1 FROM "nums" WHERE n < 10
)
SELECT n FROM "nums";

-- ============================================
-- Locking clauses and concurrency
-- ============================================

-- Select for update with skip locked (standard: FOR UPDATE; SKIP LOCKED is standard SQL:2008)
SELECT a."project_id", a."employee_id"
FROM "assignment" a
ORDER BY a."assigned_at"
    FOR UPDATE SKIP LOCKED;

-- ============================================
-- Triggers (standard: CREATE TRIGGER)
-- ============================================

-- Audit table
CREATE TABLE "audit_log"
(
    "audit_id"     INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    "table_name"   CHARACTER VARYING(100) NOT NULL,
    "row_id"       INTEGER,
    "action"       CHARACTER VARYING(10) NOT NULL,
    "at_time"      TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);

-- NOTE: Standard SQL/PSM trigger body uses the SQL procedural language.
-- Here we use a concise standard-compliant WHEN + INSERT statement trigger.
CREATE TRIGGER "trg_assignment_insert"
    AFTER INSERT ON "assignment"
    REFERENCING NEW ROW AS newrow
FOR EACH ROW
WHEN (newrow."allocated_pct" > 0)
BEGIN ATOMIC
INSERT INTO "audit_log" ("table_name", "row_id", "action")
    VALUES ('assignment', newrow."employee_id", 'INSERT');
END;

-- ============================================
-- Cursors (read-only, positioned UPDATE/DELETE via WHERE CURRENT OF)
-- ============================================

DECLARE "emp_cur" CURSOR FOR
SELECT "employee_id", "salary" FROM "employee" WHERE "company_id" = 1
ORDER BY "salary" DESC;

OPEN "emp_cur";

-- Positioned UPDATE using cursor (standard)
FETCH NEXT FROM "emp_cur";
UPDATE "employee"
SET "salary" = "salary" * 1.01
WHERE CURRENT OF "emp_cur";

CLOSE "emp_cur";

-- ============================================
-- Error handling demo with SAVEPOINT and rollback segment
-- ============================================

START TRANSACTION;
SAVEPOINT "sp1";
UPDATE "employee" SET "salary" = "salary" - 1000.00;
-- Oops, too aggressive? Roll back to savepoint.
ROLLBACK TO SAVEPOINT "sp1";
-- Apply a safer adjustment
UPDATE "employee" SET "salary" = "salary" - 100.00
WHERE "salary" > 80000.00;
COMMIT;

-- ============================================
-- Cleanup queries (optional for parser coverage)
-- ============================================

-- DROP VIEW with CASCADE/RESTRICT (choose one per engine; both are standard keywords)
DROP VIEW "v_salary_rank" RESTRICT;
DROP VIEW "v_active_projects" CASCADE;

-- DROP TRIGGER
DROP TRIGGER "trg_assignment_insert" ON "assignment";

-- DROP TABLES (order matters due to FKs)
DROP TABLE "audit_log";
DROP TABLE "assignment";
DROP TABLE "contact_pref";
DROP TABLE "project";
DROP TABLE "employee";
DROP TABLE "company";

-- DROP TYPES and DOMAIN
DROP TYPE "address_t" RESTRICT;
DROP TYPE "usd_amount" RESTRICT;
DROP DOMAIN "email_dom" RESTRICT;

-- Finally, drop schema
DROP SCHEMA "test_lab" RESTRICT;
